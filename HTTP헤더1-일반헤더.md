# HTTP 헤더 개요

헤더들이 너무많아서 두가지로 분류
캐시와 조건부 관련 헤더들
그리고 일반 헤더로 구분해서 진행할것이다

일반헤더

개요를 먼저

HTTP 메서드에서 봤던거 복습해보자

header-field = field-name ":" OWS field-value OWS (OWS:띄어쓰기 허용)

field-name은 대소문자 구문 없음

HTTP 헤더
용도
• HTTP 전송에 필요한 모든 부가정보
• 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐
시 관리 정보...
• 표준 헤더가 너무 많음
• https://en.wikipedia.org/wiki/List_of_HTTP_header_fields
• 필요시 임의의 헤더 추가 가능

헤더를 과거에 RFC2616 버전인데요

과거에는 헤더를 어떻게 분류했냐면 크게 4가지로 구별했어요

General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close

이거는 메시지 전체에 적용되는 정보 요청메세지든 응답메세지든지에 상관없이 메세지 전체에 적용되는 헤더였구요

• Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..)

Request 헤더는 요청을 보낼때 해당되는 헤더

• Response 헤더: 응답 정보, 예) Server: Apache

Response 헤더는 요청을 보낼때 해당되는 헤더

둘의 예를 들면 요청 헤더 같은 경우는 User-Agent가 오고 웹브라우저 정보가 뭔지 응답 헤더 같은 경우에는 요청을 받아서 처리하는 서버 정보가 무엇인지 

• Entity 헤더: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 3423

그리고 한가지 중요한게 있는데요 Entity 헤더 인데 메시지 바디에 해당하는 정보들 Content-Type이라던가 길이에 관한 정보들 
html인지 json인지 이런정보들이다.

실제 데이터 본문을 우리는 메시지 본문이라 부르죠?

• 메시지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용

메시지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용된다'라고 과거에 정의가 되어 있었구요

• 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터

그래서 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터가 엔티티본문이다. 쉽게말해서 메시지 본문안에 엔티티 본문을 담아서 전송한다라고 생각하면 될거에요

• **엔티티 헤더**는 **엔티티 본문**의 데이터를 해석할 수 있는 정보 제공

자 그런데 엔티티 헤더라는게 있어요 이건 엔티티 본문의 데이터를 해석할 수 있는 정보 제공해 줘요
예를 들어서 컨텐트 타입이랑 랭스는 뭐냐면 메시지본문 또는 엔티티본문이 text인지 json인지 컨텐트 길이는 뭔지 메시지 본문을 해석하기 위한 정보들이 들어있다는 것 

• 데이터 유형(html, json), 데이터 길이, 압축 정보 등등

데이터 유형이 뭔지 데이터 길이가 뭔지 어떤 압축되어 있는지  

자 그런데 

물론 엔티티와 관련되지 않은 정보들도 많이 있어요 유저 에이전트 서버 정보 이런것들은 엔티티와 전혀 관련이 없죠 
보낼 메세지와 전혀 관련이 없죠? 그런데 이게 이제 스펙이 바뀌어요

요 RFC2616이 폐기가 되요 왜냐

2014년에 RFC7230 ~ 7235로 스펙이 쪼개지면서 많이 개정이 되요

그러면서 엔티티바디라는 용어가 사라집니다.

엔티티 라는 용어가 사라지는 대신 표현(representation)이라는 용어가 들어오구요

표현은...
Representation = representation Metadata + Representation Data

자 그래서 최신 스펙에서는 이렇게 되어있습니다 어떻게 되어있냐면

• 메시지 본문(message body)을 통해 표현 데이터 전달

메시지 본문을 통해 표현 데이터 전달해요
엔티티라는 용어가 다사라져 버렸죠

• 메시지 본문 = 페이로드(payload)

메시지 본문은 실제로 데이터를 실어 나를 우리는 페이로드(payload)라고도 하거든요? 페이로드고

• **표현**은 요청이나 응답에서 전달할 실제 데이터

표현은 요청이나 응답에서 전달할 실제 데이터라고 이해하시면 되요
해서 표현 헤더는 표현 데이터를 합치면 그게 표현이 되겠죠?

• **표현 헤더는 표현 데이터**를 해석할 수 있는 정보 제공

표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공을 합니다

• 데이터 유형(html, json), 데이터 길이, 압축 정보 등등

데이터 유형, 데이터 길이, 압축 정보 등등 을 다 포함해서 이런 http body의 정보들을 제공합니다.

• 참고: 표현 헤더는 표현 메타데이터와, 페이로드 메시지를 구분해야 하지만, 여기서는 생략

아무튼 정리를 하면 
표현에 대해 이제 말을 할건데
이게 왜 표현이라고 얘기를 하냐면
예를들어서 페이로드가 회원에 대한 회원 조회 내역을 html로 제공을 해줘요. 근데 이거는 회원조회라는 자원을 html로 표현을 한거죠?

그리고 예를 들어서 회원데이터가 db에 들어있는데 이걸 json으로 조회를 해요 그러면 회원이라는 뭔가 이 회원이라는 리소스를 실제 데이터가 http에서 전송이 될때는 html로 표현이 될수도 있고 json으로 표현이 될수도 있죠? 그래서 실제 전달하는 거를 표현이라고 명확하게 용어로 정리를 했습니다.

Represent의 R이 restful의 R입니다.


# 표현

표현과 관련된 헤더들에 대해서 알아보겠습니다

자아~ 리소스가 있다고 했었죠?

회원 리소스가 있다고 생각해보죠 회원 리소스를 html형식으로 전송할꺼야 아니면 json 형식으로 전송할거야

회원이라는 리소스가 있어 이거를 html이라는 표현으로 전달할거야 아니면 json이라는 데이터 형태로 전달할거야 

이해가 되죠?

실제 리소스라는 것은 추상적이거든요?

이거를 클라이언트랑 서버간에 서로 주고 받을 때는 서로간에 주고받고 이해할수 있는 뭔가로 변환해서 데이터 전달한단 말이에요?
데이터베이스에있는 바이트 데이터를 그대로 전달할수는 없잖아요?

그래서 이제 byte코드로 가기도 하고 xml로 가기도하고 json으로 전송하기도 하는데 이거를 이걸 json으로 표현한다 xml로 표현한다 html로 표현한다라고 이렇게 이해해주시면 될거 같아요 

• Content-Type: 표현 데이터의 형식
은 이구요
• Content-Encoding: 표현 데이터의 압축 방식
은 이구요

• Content-Language: 표현 데이터의 자연 언어
은 이구요
• Content-Length: 표현 데이터의 길이
은 이구요
• 표현 헤더는 전송, 응답 둘다 사용

참고로 표현헤더는 정송과 응답 둘다에 사용할수 있구요

컨텐트 렝스는 헤더라기 보다는 실제 들어가는 거에대한 내용이어서 페이로드에 해당하지만 그냥 표현 헤더에 묶어서 말할게요


자 그래서 

Content-Type

먼저이제 컨텐트 타입은요?
이건 이제 컨텐트 바디에들어가는 내용이 뭐야?라는 거에요

표현 데이터의 형식 설명
• 미디어 타입, 문자 인코딩
• 예)
• text/html; charset=utf-8
• application/json

참고로 charset은 기본이 UTF-8이다

• image/png

Content-Encoding
표현 데이터 인코딩

그 다음에 컨텐트 인코딩은 뭐냐면요
표현데이터에 대한 인코딩인데


• 표현 데이터를 압축하기 위해 사용

표현 데이터를 주로 압축할 때 많이 씁니다
요즘에 gzip 압축같은거 많이 쓰죠?

• 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가

데이터를 전달하는 곳에서 이 실제 메시지 바디에 있는 부분을 gzip같은 걸로 압축을 쫘악 합니다.
그다음에 그러면 압축을 했으면
예를 들어서 서버에서 뭔가 클라이언트에서 보낼때 압축을 해서 보내요 클라이언트가 어?이게 뭘로 압축이 되어있는거지?알아야되잖아요?
자 그래서 여기 보시면
Content-Encoding: gzip라고 추가정보를 보내주는 거에요
그래야

• 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제

클라이언트 쪽에서 압축을 까볼수 풀수 있겠죠?

• 예)
• gzip
• deflate
• identity

참고로 identity가 뭐냐면 압축안하겠다는 거에요

Content-Language
표현 데이터의 자연 언어

• 표현 데이터의 자연 언어를 표현

표현언어의 자연언어를 표현하는 거에요

• 예)
• ko
• en
• en-US

Content-Length
표현 데이터의 길이

Content-Length는 표현 데이터의 길이구요

• 바이트 단위

참고로 바이트 단위이고

• Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨

왜 안되냐면 Transfer-Encoding(전송 코딩)안에 그러한 정보들이 다 들어있거든요 그래서 그때는 Content-Length를 쓰면 안되요


# 콘텐츠 협상

협상(콘텐츠 네고시에이션)
클라이언트가 선호하는 표현 요청

요거는 딱 그거에요 클라이언트랑 서버가 있는데 클라이언트가 원하는 표현을 달라고 서버한테 요청을 하는거에요.
서버가 '아 그래?' 클라이언트가 원하는 우선순위가 요거니까 원하는 우선순위로 해볼게 니가원하는 표현데이터로 내가 만들어 줄께! 

• Accept: 클라이언트가 선호하는 미디어 타입 전달
• Accept-Charset: 클라이언트가 선호하는 문자 인코딩
• Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
• Accept-Language: 클라이언트가 선호하는 자연 언어
• 협상 헤더는 요청시에만 사용

이 협상헤더는 요청시에만 사용합니다.


클라이언트가 서버에 요청을 할때 이렇게 하는거에요 Accept-Language라고 해서 내가 선호하는 언어는 한국어에요라고해서 클라이언트에서 서버로 이렇게 보내는 거에요

그러면서버가 어떻게 하냐면 본인의 기본언어는 영어지만 한국어를 지원하기때문에 '어허 그렇군요 당신이 원하는 거는 클라이언트 웹브라우저가 원하는 것은 한국어군요'해서 Content-Language를 ko 로 하고 실제 메시지 바디 한국어 데이터를 넣어서 보내게 됩니다.

이게 되게 작지만 굉장히 큰 이점이 있죠

헤더로 이런걸 처리하는거에요 

자 근데 좀 복잡한 예시가 있습니다

항상 깔끔하게 떨어지지 않죠? 실무는 복잡하니까요

이번에는 Accept-Language를 ko로 보냈어요 다중언어를 지원하지만 기본이 독일어에요
그런데 영어도 지원을 해요
자 그러면 내가원하는건 뭐냐면 난 가급적 한국어를 원하고 그래도 독일어보다는 영어를 원해
요런거를 위해서 우선순위가 필요합니다

협상과 우선순위1
Quality Values(q)

퀄리티 벨류라는게 있어요

• Quality Values(q) 값 사용
• 0~1, 클수록 높은 우선순위
• 생략하면 1
• Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
• 1. ko-KR;q=1 (q생략)
• 2. ko;q=0.9
• 3. en-US;q=0.8
• 4. en:q=0.7


협상과 우선순위2
Quality Values(q)

두번째는 구체적인것이 우선이에요

• 구체적인 것이 우선한다.
• Accept: text/*, text/plain, text/plain;format=flowed, */*
1. text/plain;format=flowed
2. text/plain
3. text/*
4. */*

아래 구체적인것을 우선으로 우선순위를 가져간다


# 전송방식

전송 방식
• Transfer-Encoding
• Range, Content-Range

전송 방식 설명
• 단순 전송
• 압축 전송
• 분할 전송
• 범위 전송


단순 전송
Content-Length

첫번째 단순 전송은 그냥 요청을 하면 응답을 주는데
이 메세지 바디에 대한 컨텐트 랭스를 딱 지정을 하는거에요
그니까 컨텐트에대한 길이를 알수 있을때 쓰는 거에요
길이를 알고 딱 그러니까 길이값을 주는거죠
단순하게 길이를 요청하고 한번에 쭉 받는거에요
그래서 제가 그냥 단순전송이라고 했습니다
한번에 요청하고 한번에 쭉 받는거 

압축 전송
Content-Encoding

압축전송은 이제 실제로 gzip같은걸로 쭉 압축을 하는거에요 그럼 용량이 많이 줄어들겠죠? 절반이상 줄어드는 경우가 굉장히 많아요
대신에 이러한 경우에는 Content-Encoding: gzip라는 것을 추가로 넣어줘야 해요 그래서 뭘로 압축되어있는지 알려줘야해요

분할 전송
Transfer-Encoding

이경우는 말그대로 분할해서 전송 쪼개서 전송
참고로 분할 전송시에는 컨텐트 랭스를 보내면 안됩니다
왜냐 처음에 일단 예상이 안되요 

범위 전송
Range, Content-Range

예를 들어서 이미지를 받는데 절반정도 받았는데 끊겼어요
다시 요청해야해 그럼 처음부터 다시 요청하면 용량이 아깝잖아요
그래서 범위 전송같은 경우에는 요렇게 범위를 딱 지정해서 요청할수 있어요 

# 일반정보


Server
요청을 처리하는 ORIGIN 서버의 소프트웨어 정보

ORIGIN 서버? http를 하면 여러 프록시서버를 거치게 되요
실제 요청이 도착해서 실제로 응답을 해주는 진짜서버 그 서버를
**ORIGIN 서버**라고 합니다

• Server: Apache/2.2.22 (Debian)
• server: nginx
• 응답에서 사용


Date
메시지가 발생한 날짜와 시간

과거에는 요청에서도 사용했지만 최신스펙은 응답에서만 사용

• Date: Tue, 15 Nov 1994 08:12:31 GMT
• 응답에서 사용

# 특별한 정보

Host
요청한 호스트 정보(도메인)

이거는 요청에서 사용하는데 진짜중요합니다 필수 값입니다
다른헤더들은 

• 요청에서 사용
• 필수
• 하나의 서버가 여러 도메인을 처리해야 할 때
• 하나의 IP 주소에 여러 도메인이 적용되어 있을 때

가상호스트라는 개념이 있어요 뭐냐면
하나의 서버에 여러개의 애플리케이션이 구동되어있을수 있거든요?
그런데
문제는 이거에요
/hello라고 해서 요청을 보내요
그럼 어떤 애플리케이션에서 구동해야할지 몰라 방법이 없는거에요
초창기에 그래서 host 헤더는 무조건 넣어야된다고 스펙이 개정이 되었구요
그래서 호스트 네임은 필수다 이렇게 이해해주세요

Allow
허용 가능한 HTTP 메서드
• 405 (Method Not Allowed) 에서 응답에 포함해야함
• Allow: GET, HEAD, PUT

있지만 잘 구현 안된다

# 인증

인증
• Authorization: 클라이언트 인증 정보를 서버에 전달
• WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의

인증과 관련된 헤더는

Authorization이 있구요 이걸 넘기면 클라이언트 인증 정보를 서버에 전달할 수가 잇습니다.

WWW-Authenticate가 뭐냐면 리소스 접근시 필요한 인증 방법을 정의하는 건데요

Authorization
클라이언트 인증 정보를 서버에 전달
• Authorization: Basic xxxxxxxxxxxxxxxx

참고로 인증과 관련되어서는 인증하는 여러가지 메커니즘이 있거든요
Outh, Auth2 무슨인증 무슨무슨 인증이 있는데 이 벨류(=xxxxxxxxxxxxxxxx)에 들어가는 거는 완전히 달라요

어떤 메커니즘이냐에 상관없이 일단 헤더를 제공하는거에요 그리고 요기에 인증과 관련된 값을 넣어주면 되겠죠?


WWW-Authenticate
리소스 접근시 필요한 인증 방법 정의
• 리소스 접근시 필요한 인증 방법 정의
• 401 Unauthorized 응답과 함께 사용
• WWW-Authenticate: Newauth realm="apps", type=1,
 title="Login to \"apps\"", Basic realm="simple"

그런데 이 헤더는 뭐냐면
만약에 뭔가 접근을 했는데 인증이 안되거나 문제가 있어요
그러면 401 Unauthorized 남기고  응답과 함께 사용하는데요

요 401 오류가 날때 WWW-Authenticate: Newauth realm="apps", type=1,
 title="Login to \"apps\"", Basic realm="simple" 요 헤더를 넣어줘야 해요
 그래서 아~ 니가 인증을 하려면 요런 정보들을 참고해서 제대로된 인증을 만들어라고 해서 서버에서 클라이언트로 반환하게 됩니다.