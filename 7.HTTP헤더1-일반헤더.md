# HTTP 헤더 개요

헤더들이 너무많아서 두가지로 분류
캐시와 조건부 관련 헤더들
그리고 일반 헤더로 구분해서 진행할것이다

## HTTP 헤더

일반헤더
개요를 먼저보자

HTTP 메서드에서 봤던거 복습해보자

- header-field = field-name ":" OWS field-value OWS (OWS:띄어쓰기 허용)

- field-name은 대소문자 구문 없음

![image](https://user-images.githubusercontent.com/53653597/147473286-6c1202a0-7b30-4742-a175-0e4a4d1fd39b.png)

**용도**

- HTTP 전송에 필요한 모든 부가정보
- 예) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보...
- 표준 헤더가 너무 많음
    - https://en.wikipedia.org/wiki/List_of_HTTP_header_fields
- 필요시 임의의 헤더 추가 가능

헤더를 볼게요 과거에 RFC2616 버전인데요

![image](https://user-images.githubusercontent.com/53653597/147473823-5bfba677-16ec-4380-970f-5a962c0a7629.png)

과거에는 헤더를 어떻게 분류했냐면 크게 4가지로 구별했어요

- General 헤더: 메시지 전체에 적용되는 정보, 예) Connection: close

메시지 전체에 적용되는 정보입니다. 요청메세지든 응답메세지든지에 상관없이 메세지 전체에 적용되는 헤더이구요

Request 헤더는 요청을 보낼때 해당되는 헤더
- Request 헤더: 요청 정보, 예) User-Agent: Mozilla/5.0 (Macintosh; ..)


Response 헤더는 요청을 보낼때 해당되는 헤더
- Response 헤더: 응답 정보, 예) Server: Apache
```javascript
둘의 예를 들면 
요청 헤더 같은 경우는 User-Agent가 오고 웹브라우저 정보가 뭔지 
응답 헤더 같은 경우에는 요청을 받아서 처리하는 서버 정보가 뭔지
알려줍니다.
```
그리고 한가지 중요한게 있는데요 

Entity 헤더 인데 메시지 바디에 해당하는 정보들 Content-Type이라던가 길이에 관한 정보들 html인지 json인지 이런정보들입니다.

- Entity 헤더: 엔티티 바디 정보, 예) Content-Type: text/html, Content-Length: 3423

- 메시지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용

- 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터

- ### **엔티티 헤더**는 **엔티티 본문**의 데이터를 해석할 수 있는 정보 제공

    - 데이터 유형(html, json), 데이터 길이, 압축 정보 등등

실제 데이터 본문을 우리는 메시지 본문이라 부르죠?

메시지 본문(message body)은 엔티티 본문(entity body)을 전달하는데 사용된다'라고 과거에 정의가 되어 있었구요

그래서 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터가 엔티티본문입니다. 쉽게말해서 메시지 본문안에 엔티티 본문을 담아서 전송한다라고 생각하면 될거에요

![image](https://user-images.githubusercontent.com/53653597/147476772-92901964-c2f5-4a7d-b9cb-f8ece0b95a06.png)

자 다시! 
엔티티 헤더라는게 있어요

이건 엔티티 본문의 데이터를 해석할 수 있는 정보 제공해 줘요

예를 들어서 Content-Type이랑 Content-Length는 뭐냐면 메시지본문 또는 엔티티본문이 text인지 json인지 컨텐트 길이는 뭔지 메시지 본문을 해석하기 위한 정보들입니다. 

데이터 유형이 뭔지 데이터 길이가 뭔지 어떤 압축되어 있는지  

자 그런데 

물론 엔티티와 관련되지 않은 정보들도 많이 있어요 유저 에이전트 서버 정보 이런것들은 엔티티와 전혀 관련이 없죠 
보낼 메세지와 전혀 관련이 없죠? 그런데 이게 이제 스펙이 바뀌어요

RFC2616이 폐기가 되요 왜냐

2014년에 RFC7230 ~ 7235로 스펙이 쪼개지면서 많이 개정이 돼요

그러면서 엔티티바디라는 용어가 사라집니다.

엔티티 라는 용어가 사라지는 대신 `표현(representation)`이라는 용어가 들어오구요

```
표현은...
Representation = representation Metadata + Representation Data
```
자 그래서 최신 스펙에서는 이렇게 되어있습니다 어떻게 되어있냐면

메시지 본문을 통해 표현 데이터 전달해요 엔티티라는 용어가 다사라져 버렸죠

- 메시지 본문(message body)을 통해 표현 데이터 전달

메시지 본문은 실제로 데이터를 실어 나른다고해서 우리는 페이로드(payload)라고도 하거든요? 페이로드라 부르게 되고요

- 메시지 본문 = 페이로드(payload)

표현은 요청이나 응답에서 전달할 실제 데이터라고 이해하시면 되요
해서 표현 헤더는 표현 데이터를 합치면 그게 표현이 되겠죠?

- **표현**은 요청이나 응답에서 전달할 실제 데이터


- **표현 헤더는 표현 데이터**를 해석할 수 있는 정보 제공
    - 데이터 유형(html, json), 데이터 길이, 압축 정보 등등

표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공을 합니다

데이터 유형, 데이터 길이, 압축 정보 등등 을 다 포함해서 이런 http body의 정보들을 제공합니다.

- 참고: 표현 헤더는 표현 메타데이터와, 페이로드 메시지를 구분해야 하지만, 여기서는 생략

아무튼 정리를 하면 
표현에 대해 이제 말을 할건데
이게 왜 표현이라고 얘기를 하냐면
예를들어서 페이로드가 회원에 대한 회원 조회 내역을 html로 제공을 해줘요. 근데 이거는 회원조회라는 자원을 html로 표현을 한거죠?

그리고 예를 들어서 회원데이터가 db에 들어있는데 이걸 json으로 조회를 해요 그러면 회원이라는 뭔가 이 회원이라는 리소스를 실제 데이터가 http에서 전송이 될때는 html로 표현이 될수도 있고 json으로 표현이 될수도 있죠? 그래서 실제 전달하는 거를 표현이라고 명확하게 용어로 정리를 했습니다.

Represent의 R이 restful의 R입니다.


# 표현

표현과 관련된 헤더들에 대해서 알아보겠습니다

자아~ 리소스가 있다고 했었죠?

회원 리소스가 있다고 생각해보죠 회원 리소스를 html형식으로 전송할꺼야 아니면 json 형식으로 전송할거야

회원이라는 리소스가 있어 이거를 html이라는 표현으로 전달할거야 아니면 json이라는 데이터 형태로 전달할거야 

이해가 되죠?

실제 리소스라는 것은 추상적이거든요?

이거를 클라이언트랑 서버간에 서로 주고 받을 때는 서로간에 주고받고 이해할수 있는 뭔가로 변환해서 데이터 전달한단 말이에요?
데이터베이스에있는 바이트 데이터를 그대로 전달할수는 없잖아요?

그래서 이제 byte코드로 가기도 하고 xml로 가기도하고 json으로 전송하기도 하는데 이거를 이걸 json으로 표현한다 xml로 표현한다 html로 표현한다라고 이렇게 이해해주시면 될거 같아요 

- Content-Type: 표현 데이터의 형식
- Content-Encoding: 표현 데이터의 압축 방식
- Content-Language: 표현 데이터의 자연 언어
- Content-Length: 표현 데이터의 길이
- 표현 헤더는 전송, 응답 둘다 사용

참고로 표현헤더는 전송과 응답 둘다에 사용할수 있구요

Content-Length는 헤더라기 보다는 실제 들어가는 거에대한 내용이어서 페이로드에 해당하지만 그냥 표현 헤더에 묶어서 정리하겠습니다.


자 그래서 

## **Content-Type**
**표현 데이터의 형식 설명**

먼저이제 컨텐트 타입은요?
이건 이제 컨텐트 바디에들어가는 내용이 뭐야?라는 거에요

![image](https://user-images.githubusercontent.com/53653597/147571883-9d7616c3-b1af-4864-95c4-6c1c5e5a9e7d.png)

- 미디어 타입, 문자 인코딩
- 예)
    - text/html; charset=utf-8
    - application/json
    - image/png

*참고로 charset은 기본이 UTF-8이다*


## **Content-Encoding**
**표현 데이터 인코딩**


- 표현 데이터를 압축하기 위해 사용
- 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
- 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
- 예)
    - gzip
    - deflate
    - identity

![image](https://user-images.githubusercontent.com/53653597/147572386-8cd521c5-276d-479d-aee4-757247c67b3f.png)

그 다음에 컨텐트 인코딩은 뭐냐면요
표현데이터에 대한 인코딩인데
표현 데이터를 주로 압축할 때 많이 씁니다
gzip 압축같은거 많이 쓰죠?

데이터를 전달하는 곳에서 이 실제 메시지 바디에 있는 부분을 gzip같은 걸로 압축을 합니다.
 그 다음에 압축을 했으면
예를 들어서 서버에서 뭔가 클라이언트에서 보낼때 압축을 해서 보내요 클라이언트가 어?이게 뭘로 압축이 되어있는거지? 알아야되잖아요?
자 그래서 여기 보시면
Content-Encoding: gzip라고 추가정보를 보내주는 거에요
그래야 클라이언트 쪽에서 압축을 풀 수 있겠죠?

*참고로 identity는 압축안하겠다는 뜻입니다*

## **Content-Language**
**표현 데이터의 자연 언어**

- 표현 데이터의 자연 언어를 표현
- 예)
    - ko
    - en
    - en-US

![image](https://user-images.githubusercontent.com/53653597/147572643-b9133d12-ad02-46e8-b134-50d8277024f9.png)

## **Content-Length**
**표현 데이터의 길이**

Content-Length는 표현 데이터의 길이구요

- 바이트 단위

참고로 바이트 단위이고

- Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨

왜 안돼냐면 `Transfer-Encoding(전송 코딩)안에 Content-Length 뿐만아니라 기타 다른 정보들이 들어있기 떄문에` Content-Length를 쓰면 안되요


# 콘텐츠 협상

**협상(콘텐츠 네고시에이션)**

클라이언트가 선호하는 표현 요청

요거는 딱 그거에요 클라이언트랑 서버가 있는데 클라이언트가 원하는 표현을 달라고 서버한테 요청을 하는거에요.
서버가 '아 그래?' 클라이언트가 원하는 우선순위가 요거니까 원하는 우선순위로 해볼게 니가원하는 표현데이터로 내가 만들어 줄께! 

- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accept-Language: 클라이언트가 선호하는 자연 언어
- 협상 헤더는 요청시에만 사용

이 협상헤더는 요청시에만 사용합니다.

![image](https://user-images.githubusercontent.com/53653597/147573407-3266dfa5-776d-4862-bbd9-066d5ee3cb47.png)

클라이언트가 서버에 요청을 할때 이렇게 하는거에요 Accept-Language라고 해서 내가 선호하는 언어는 한국어에요라고해서 클라이언트에서 서버로 이렇게 보내는 거에요

그러면서버가 어떻게 하냐면 본인의 기본언어는 영어지만 한국어를 지원하기때문에 '어허 그렇군요 당신이 원하는 거는 클라이언트 웹브라우저가 원하는 것은 한국어군요'해서 Content-Language를 ko 로 하고 실제 메시지 바디 한국어 데이터를 넣어서 보내게 됩니다.

이게 되게 작지만 굉장히 큰 이점이 있죠

헤더로 이런걸 처리하는거에요 

자 근데 좀 복잡한 예시가 있습니다

항상 깔끔하게 떨어지지 않죠? 실무는 복잡하니까요

![image](https://user-images.githubusercontent.com/53653597/147573535-6e8c0014-83fc-4ebf-90a3-7e099056e8b9.png)

이번에는 Accept-Language를 ko로 보냈어요 다중언어를 지원하지만 기본이 독일어에요
그런데 영어도 지원을 해요
자 그러면 내가원하는건 뭐냐면 난 가급적 한국어를 원하고 그래도 독일어보다는 영어를 원해
요런거를 위해서 우선순위가 필요합니다

### 협상과 우선순위1
Quality Values(q)

퀄리티 벨류라는게 있어요

![image](https://user-images.githubusercontent.com/53653597/147573625-1a1b4a10-6947-46a9-81bb-3bd7e151381f.png)

- Quality Values(q) 값 사용
- 0~1, 클수록 높은 우선순위
- 생략하면 1
- Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
    1. ko-KR;q=1 (q생략)
    2. ko;q=0.9
    3. en-US;q=0.8
    4. en:q=0.7


### 협상과 우선순위2
Quality Values(q)

두번째는 구체적인것이 우선이에요

- 구체적인 것이 우선한다.

아래 구체적인것을 우선으로 우선순위를 가져간다

- Accept: text/*, text/plain, text/plain;format=flowed, */*
1. text/plain;format=flowed
2. text/plain
3. text/*
4. \*/\*

### 협상과 우선순위3
Quality Values(q)
- 구체적인 것을 기준으로 미디어 타입을 맞춘다.
- Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
 text/html;level=2;q=0.4, */*;q=0.5

![image](https://user-images.githubusercontent.com/53653597/147574312-8830133a-1481-4b99-a0ca-ca2504dc20b4.png)


# 전송방식

**전송 방식**
- Transfer-Encoding
- Range, Content-Range

### 전송 방식 설명
- 단순 전송
- 압축 전송
- 분할 전송
- 범위 전송


## **단순 전송**
**Content-Length**

![image](https://user-images.githubusercontent.com/53653597/147651659-dd2593d7-da12-425a-bfbd-06cc05520496.png)

첫번째 단순 전송은 그냥 요청을 하면 응답을 주는데
이 메세지 바디에 대한 컨텐트 랭스를 딱 지정을 하는거에요
그니까 **`컨텐트에 대한 길이를 알수 있을 때`** 쓰는 거에요
길이를 알고 딱 그러니까 길이값을 주는거죠
단순하게 길이를 요청하고 한번에 쭉 받는거에요
그래서 제가 그냥 단순전송이라고 했습니다
한번에 요청하고 한번에 쭉 받는거 

## **압축 전송**
**Content-Encoding**

![image](https://user-images.githubusercontent.com/53653597/147652443-72019112-2862-4b56-bef0-6399146b9da5.png)

압축전송은 이제 실제로 gzip같은걸로 쭉 압축을 하는거에요 그럼 용량이 많이 줄어들겠죠? 절반이상 줄어드는 경우가 굉장히 많아요
대신에 이러한 경우에는 **`Content-Encoding`**: gzip라는 것을 추가로 넣어줘야 해요 그래서 뭘로 압축되어있는지 알려줘야해요

## **분할 전송**
**Transfer-Encoding**

![image](https://user-images.githubusercontent.com/53653597/147652577-2f0c8aaf-c773-406c-9547-a71561fe8f8d.png)

이 경우는 말그대로 분할해서 전송 쪼개서 전송
참고로 **`분할 전송시에는 컨텐트 랭스를 보내면 안됩니다`**
왜냐하면 처음에 일단 예상이 안되기 때문입니다.

## **범위 전송**
**Range, Content-Range**

![image](https://user-images.githubusercontent.com/53653597/147652831-0da34b73-1d04-4fa6-b8b5-65cd2f3c1ef8.png)

예를 들어서 이미지를 받는데 절반정도 받았는데 끊겼어요
다시 요청해야해 그럼 처음부터 다시 요청하면 용량이 아깝잖아요
그래서 범위 전송같은 경우에는 이렇게 **`범위를 지정해서 요청`** 할 수 있어요 

# 일반정보

- From: 유저 에이전트의 이메일 정보
- Referer: 이전 웹 페이지 주소
- User-Agent: 유저 에이전트 애플리케이션 정보
- Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
- Date: 메시지가 생성된 날짜

## **From**
**유저 에이전트의 이메일 정보**
- 일반적으로 잘 사용되지 않음
- 검색 엔진 같은 곳에서, 주로 사용
- 요청에서 사용

## **Referer**
**이전 웹 페이지 주소**

- 현재 요청된 페이지의 이전 웹 페이지 주소
- A -> B로 이동하는 경우 B를 요청할 때 Referer: A 를 포함해서 요청
- Referer를 사용해서 유입 경로 분석 가능
- 요청에서 사용
- 참고: referer는 단어 referrer의 오타

## **Server**
**요청을 처리하는 ORIGIN 서버의 소프트웨어 정보**

ORIGIN 서버? http를 하면 여러 프록시서버를 거치게 되요

**`실제 요청이 도착해서 실제로 응답을 해주는 진짜 서버`** 그 서버를
**`ORIGIN 서버`** 라고 합니다

- Server: Apache/2.2.22 (Debian)
- server: nginx
- 응답에서 사용


## **Date**
**메시지가 발생한 날짜와 시간**

과거에는 요청에서도 사용했지만 최신 스펙은 **응답에서만 사용**

- Date: Tue, 15 Nov 1994 08:12:31 GMT
- 응답에서 사용

# 특별한 정보

## Host: 요청한 호스트 정보(도메인)

이거는 요청에서 사용하는데 진짜중요합니다 필수 값입니다

- 요청에서 사용
- 필수
- 하나의 서버가 여러 도메인을 처리해야 할 때
- 하나의 IP 주소에 여러 도메인이 적용되어 있을 때

![image](https://user-images.githubusercontent.com/53653597/147657387-b2cd1678-7eac-47d3-994b-cd615b7d9633.png)

가상호스트라는 개념이 있어요 뭐냐면
하나의 서버에 여러개의 애플리케이션이 구동되어있을수 있거든요?
그런데
문제는 이거에요
/hello라고 해서 요청을 보내요
그럼 어떤 애플리케이션에서 구동해야할지 몰라 방법이 없는거에요
초창기에 그래서 host 헤더는 무조건 넣어야된다고 스펙이 개정이 되었구요
그래서 **`호스트 네임은 필수다`** 이렇게 이해해주세요

## Location: 페이지 리다이렉션

- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)
- 응답코드 3xx에서 설명
- 201 (Created): Location 값은 요청에 의해 생성된 리소스 URI
- 3xx (Redirection): Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴

## Allow: 허용 가능한 HTTP 메서드

- 405 (Method Not Allowed) 에서 응답에 포함해야함
- Allow: GET, HEAD, PUT

있지만 잘 구현 안된다

## Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

- 503 (Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음
- Retry-After: Fri, 31 Dec 1999 23:59:59 GMT (날짜 표기)
- Retry-After: 120 (초단위 표기)

# 인증

인증
- Authorization: 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의

인증과 관련된 헤더는

Authorization이 있구요 이걸 넘기면 클라이언트 인증 정보를 서버에 전달할 수가 잇습니다.

WWW-Authenticate가 뭐냐면 리소스 접근시 필요한 인증 방법을 정의하는 건데요

Authorization
클라이언트 인증 정보를 서버에 전달
- Authorization: Basic xxxxxxxxxxxxxxxx

참고로 인증과 관련되어서는 인증하는 여러가지 메커니즘이 있거든요
Outh, Auth2 무슨인증 무슨무슨 인증이 있는데 이 벨류(=xxxxxxxxxxxxxxxx)에 들어가는 거는 완전히 달라요

어떤 메커니즘이냐에 상관없이 일단 헤더를 제공하는거에요 그리고 요기에 인증과 관련된 값을 넣어주면 되겠죠?


WWW-Authenticate
리소스 접근시 필요한 인증 방법 정의
- 리소스 접근시 필요한 인증 방법 정의
- 401 Unauthorized 응답과 함께 사용
- WWW-Authenticate: Newauth realm="apps", type=1,
 title="Login to \"apps\"", Basic realm="simple"

그런데 이 헤더는 뭐냐면
만약에 뭔가 접근을 했는데 인증이 안되거나 문제가 있어요
그러면 401 Unauthorized 남기고  응답과 함께 사용하는데요

요 401 오류가 날때 WWW-Authenticate: Newauth realm="apps", type=1,
 title="Login to \"apps\"", Basic realm="simple" 요 헤더를 넣어줘야 해요
 그래서 아~ 니가 인증을 하려면 요런 정보들을 참고해서 제대로된 인증을 만들어라고 해서 서버에서 클라이언트로 반환하게 됩니다.

 # 쿠키

- Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
- Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

예를 들어서 /welcome으로 접근을 하고 들어오면 만약에
사용자가 로그인을 하면 정보를 보내서 로그인을 했어요
홍길동님이 로그인 했습니다를 하겠죠?

자 로그인을 했단말이죠 그렇다면 그리고 나서 

/welcome을 통해 페이지 접근을 해서 안녕하세요 홍길동님을 기대를 해봤자

돌아오는 응답은 안녕하세요 손님이 될 것이다.
왜? /welcome 으로는 아무런 정보도 감지 할 수 없기 때문이다.
그저 /welcome만 왔다 서버입장에서는 아무리 눈을 씻고 찾아봐도 이게 홍길동인지 뭔지 구별할수 있는 방법이 없다 http는 한번응답을 주고 받으면 연결을 끊어지고 무상태 프로토콜이기 때문이다.

Stateless
- HTTP는 무상태(Stateless) 프로토콜이다.
- 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.
- 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
- 클라이언트와 서버는 서로 상태를 유지하지 않는다.

이게 지금 상태를 유지하지 못하니까 문제가 생기는 것이지만 일단 우리가 지향하는 프로그래밍은 무상태 이다.

쿠키 미사용
대안 - 모든 요청과 링크에 사용자 정보 포함?

대안은 모든 요청에 사용자 정보를 포함해서 보내는 것이다.

![image](https://user-images.githubusercontent.com/53653597/146754246-b00ecb5d-a0d9-4879-83dc-979c6837df68.png)

하지만 이것 또한 문제가 된다.

모든 요청에 정보를 넘기는 문제
- 모든 요청에 사용자 정보가 포함되도록 개발 해야함
- 브라우저를 완전히 종료하고 다시 열면? - 웹스토리지라는 기술이 있어 가능하지만 글쎄...

옛날부터 이런문제가 있었고 이런문제를 해결하기 위해 쿠키라는 개념이 도입이 됩니다.

웹브라우저가 Post라고 해서 요청을 보냅니다.
그러면 서버는 어떻게 하느냐
Set-Cookie라고 해서 user=홍길동이라고 해서 
홍길동이라는 이름을 쿠키에 말아요
서버에서

쿠키해더를 하나 만들어서 

웹브라우저는 어떠허게 하냐면 웹브라우저 내부에는 쿠키저장소가 있거든요?
 이 저장소에 user=홍길동 이라고하는 것을 저장해요

쿠키
모든 요청에 쿠키 정보 자동 포함

자! 그런데 
정말 모든 곳에 다 모든 곳에 이런 쿠키정보를 보내면 아무래도 보안에 문제가 되고 여러가지 문제가 있겠죠?

그래서 이걸 제약하는 방법들이 있습니다.


쿠키
- 예) set-cookie: **sessionId=abcde1234;** **expires**=Sat, 26-Dec-2020 00:00:00 GMT; **path**=/; **domain**=.google.com; **Secure**
- 사용처
    - 사용자 로그인 세션 관리
    - 광고 정보 트래킹
- 쿠키 정보는 항상 서버에 전송됨
    - 네트워크 트래픽 추가 유발
    - (그래서) 최소한의 정보만 사용(세션 id, 인증 토큰)
    - 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage,sessionStorage) 참고
- 주의!
    - 보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)

쿠키 - 생명주기
Expires, max-age
- Set-Cookie: **expires**=Sat, 26-Dec-2020 04:39:21 GMT
    • 만료일이 되면 쿠키 삭제
- Set-Cookie: **max-age**=3600 (3600초)
    • 0이나 음수를 지정하면 쿠키 삭제
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지

쿠키 - 도메인
Domain
- 예) domain=example.org
- **명시: 명시한 문서 기준 도메인 + 서브 도메인 포함**
    - domain=example.org를 지정해서 쿠키 생성
    - example.org는 물론이고
    - dev.example.org도 쿠키 접근
- **생략: 현재 문서 기준 도메인만 적용**
    - example.org 에서 쿠키를 생성하고 domain 지정을 생략
    - example.org 에서만 쿠키 접근
    - dev.example.org는 쿠키 미접근

쿠키 - 경로
Path
- 예) path=/home
- **이 경로를 포함한 하위 경로 페이지만 쿠키 접근**
- **일반적으로 path=/ 루트로 지정**
- 예)
- **path=/home 지정**
- /home -> 가능
- /home/level1 -> 가능
- /home/level1/level2 -> 가능
- /hello -> 불가능

쿠키 - 보안
Secure, HttpOnly, SameSite
- **Secure**
- 쿠키는 http, https를 구분하지 않고 전송
- **Secure를 적용하면 https인 경우에만 전송**
- **HttpOnly**
- XSS 공격 방지
- 자바스크립트에서 접근 불가(document.cookie)
- **HTTP 전송에만 사용**
- SameSite
- XSRF 공격 방지
- 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

현재 내가 요청하는 도메인과 쿠키에 설정된 도메인이 같을 경우에만 쿠키가 전송 되게 설정
사용시에는 브라우저에서 어디까지 쓸수 있는지 확인후 사용하자!!
